<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI DevOps Chatbot</title>
    <style>
      :root {
        --bg-a: #fef3c7;
        --bg-b: #e0f2fe;
        --card: #ffffff;
        --text: #1f2937;
        --muted: #6b7280;
        --border: #d1d5db;
        --bot: #e0f2fe;
        --user: #dcfce7;
        --accent: #0f766e;
        --accent-hover: #115e59;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 1.25rem;
        color: var(--text);
        font-family: "Trebuchet MS", "Segoe UI", sans-serif;
        background:
          radial-gradient(circle at 10% 10%, var(--bg-a) 0%, transparent 45%),
          radial-gradient(circle at 90% 90%, #bfdbfe 0%, transparent 40%),
          linear-gradient(140deg, #f8fafc, var(--bg-b));
      }

      .chatbot {
        width: min(880px, 100%);
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 18px;
        box-shadow: 0 16px 40px rgba(15, 23, 42, 0.16);
        overflow: hidden;
      }

      .topbar {
        padding: 1rem 1.2rem;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(90deg, #ecfeff, #eff6ff);
      }

      .topbar-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.8rem;
      }

      .title {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 700;
      }

      .subtitle {
        margin: 0.25rem 0 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .health-pill {
        border-radius: 999px;
        padding: 0.25rem 0.7rem;
        font-size: 0.74rem;
        font-weight: 700;
        letter-spacing: 0.04em;
        border: 1px solid transparent;
        white-space: nowrap;
      }

      .health-pill.healthy {
        color: #166534;
        background: #dcfce7;
        border-color: #86efac;
      }

      .health-pill.degraded {
        color: #92400e;
        background: #fef3c7;
        border-color: #fcd34d;
      }

      .health-pill.failed {
        color: #991b1b;
        background: #fee2e2;
        border-color: #fca5a5;
      }

      .messages {
        height: 430px;
        overflow-y: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        background: #f8fafc;
      }

      .snapshot {
        display: flex;
        flex-wrap: wrap;
        gap: 0.45rem;
        padding: 0.6rem 1rem 0.15rem;
        border-bottom: 1px solid #eef2f7;
        background: #fbfdff;
      }

      .metric-chip {
        border: 1px solid #dbe5f0;
        background: #ffffff;
        border-radius: 999px;
        padding: 0.25rem 0.55rem;
        font-size: 0.74rem;
        color: #334155;
      }

      .metric-chip strong {
        margin-left: 0.2rem;
        color: #0f172a;
      }

      .msg {
        max-width: min(78%, 680px);
        border-radius: 12px;
        padding: 0.7rem 0.85rem;
        line-height: 1.4;
        white-space: pre-wrap;
        display: grid;
        gap: 0.35rem;
      }

      .msg.bot {
        background: var(--bot);
        border: 1px solid #bae6fd;
        align-self: flex-start;
      }

      .msg.user {
        background: var(--user);
        border: 1px solid #bbf7d0;
        align-self: flex-end;
      }

      .controls {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        padding: 0.7rem 1rem 0;
      }

      .chip {
        border: 1px solid var(--border);
        background: #ffffff;
        border-radius: 999px;
        padding: 0.35rem 0.65rem;
        font-size: 0.82rem;
        cursor: pointer;
      }

      .msg-text {
        margin: 0;
      }

      .msg-time {
        font-size: 0.72rem;
        color: var(--muted);
        opacity: 0.9;
      }

      .typing {
        font-style: italic;
        color: #075985;
      }

      .typing-dots::after {
        content: " ...";
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.3;
        }
      }

      .composer {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 0.6rem;
        padding: 0.9rem 1rem 1rem;
      }

      .input {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 0.7rem 0.8rem;
        font-size: 1rem;
        outline: none;
      }

      .input:focus {
        border-color: #2dd4bf;
        box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.2);
      }

      .send {
        border: 0;
        border-radius: 10px;
        padding: 0.65rem 1rem;
        color: #fff;
        background: var(--accent);
        cursor: pointer;
        font-weight: 600;
      }

      .send:hover {
        background: var(--accent-hover);
      }

      .meta {
        padding: 0 1rem 1rem;
        color: var(--muted);
        font-size: 0.8rem;
      }

      @media (max-width: 700px) {
        .messages {
          height: 56vh;
        }

        .msg {
          max-width: 90%;
        }
      }
    </style>
  </head>
  <body>
    <section class="chatbot">
      <header class="topbar">
        <div class="topbar-row">
          <div>
            <h1 class="title">AI DevOps Chatbot</h1>
            <p class="subtitle">HTML chatbot UI for deployment support with quick live metrics</p>
          </div>
          <div id="health-pill" class="health-pill healthy">HEALTHY</div>
        </div>
      </header>

      <div class="snapshot">
        <div class="metric-chip">Errors <strong id="metric-errors">1.20%</strong></div>
        <div class="metric-chip">Latency <strong id="metric-latency">140ms</strong></div>
        <div class="metric-chip">CPU <strong id="metric-cpu">48%</strong></div>
        <div class="metric-chip">Memory <strong id="metric-memory">56%</strong></div>
        <div class="metric-chip">Replicas <strong id="metric-replicas">3/3</strong></div>
        <div class="metric-chip">Stability <strong id="metric-stability">--</strong></div>
        <div class="metric-chip">Autopilot <strong id="metric-autopilot">OFF</strong></div>
      </div>

      <div id="messages" class="messages"></div>

      <div class="controls">
        <button type="button" class="chip" data-q="status">Status</button>
        <button type="button" class="chip" data-q="simulate incident">Simulate Incident</button>
        <button type="button" class="chip" data-q="heal now">Heal</button>
        <button type="button" class="chip" data-q="deployment summary">Summary</button>
        <button type="button" class="chip" data-q="analytics">Analytics</button>
        <button type="button" class="chip" data-q="autopilot start 8 2">Autopilot Start</button>
        <button type="button" class="chip" data-q="autopilot status">Autopilot Status</button>
        <button type="button" class="chip" data-q="autopilot stop">Autopilot Stop</button>
        <button type="button" class="chip" data-q="help">Help</button>
        <button type="button" class="chip" id="clear-chat-btn">Clear Chat</button>
      </div>

      <form id="chat-form" class="composer">
        <input id="chat-input" class="input" type="text" placeholder="Type message..." autocomplete="off" required />
        <button class="send" type="submit">Send</button>
      </form>

      <div class="meta">Tip: ask about status, summary, analytics, errors, latency, heal, rollback, scaling, or clear. Press `/` to focus input.</div>
    </section>

    <script>
      const messages = document.getElementById("messages");
      const form = document.getElementById("chat-form");
      const input = document.getElementById("chat-input");
      const chips = document.querySelectorAll(".chip");
      const clearChatBtn = document.getElementById("clear-chat-btn");
      const healthPill = document.getElementById("health-pill");
      const metricErrors = document.getElementById("metric-errors");
      const metricLatency = document.getElementById("metric-latency");
      const metricCpu = document.getElementById("metric-cpu");
      const metricMemory = document.getElementById("metric-memory");
      const metricReplicas = document.getElementById("metric-replicas");
      const metricStability = document.getElementById("metric-stability");
      const metricAutopilot = document.getElementById("metric-autopilot");
      const API_BASE_STORAGE_KEY = "devops_backend_base";
      const api = {
        state: "/api/state",
        analytics: "/api/analytics",
        autopilot: "/api/autopilot",
        history: "/api/history",
        chat: "/api/chat",
        clear: "/api/history/clear",
      };
      const queryApiBase = new URLSearchParams(window.location.search).get("api") || "";
      let apiBase = normalizeBaseUrl(queryApiBase || window.localStorage.getItem(API_BASE_STORAGE_KEY) || "");
      if (queryApiBase) {
        window.localStorage.setItem(API_BASE_STORAGE_KEY, apiBase);
      }

      const state = {
        service: "payments-api",
        version: "-",
        status: "healthy",
        errorRate: 1.2,
        latency: 140,
        cpu: 48,
        memory: 56,
        replicas: "3/3",
        stability: null,
        autopilotLabel: "OFF",
      };

      function timestamp() {
        return new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }

      function normalizeBaseUrl(raw) {
        const text = String(raw || "").trim();
        if (!text) return "";

        let normalized = text.replace(/\/+$/, "");
        normalized = normalized.replace(/\/index\.html$/i, "");
        normalized = normalized.replace(/\/api$/i, "");

        try {
          const parsed = new URL(normalized);
          const path = parsed.pathname.replace(/\/+$/, "");
          return `${parsed.origin}${path && path !== "/" ? path : ""}`;
        } catch (err) {
          return normalized;
        }
      }

      function resolveApiUrl(path, base = apiBase) {
        if (!base) return path;
        return `${base}${path}`;
      }

      function updateHealthPill() {
        const safeStatus = ["healthy", "degraded", "failed"].includes(state.status) ? state.status : "healthy";
        healthPill.classList.remove("healthy", "degraded", "failed");
        healthPill.classList.add(safeStatus);
        healthPill.textContent = safeStatus.toUpperCase();
        updateSnapshot();
      }

      function updateSnapshot() {
        metricErrors.textContent = `${state.errorRate.toFixed(2)}%`;
        metricLatency.textContent = `${state.latency}ms`;
        metricCpu.textContent = `${state.cpu}%`;
        metricMemory.textContent = `${state.memory}%`;
        metricReplicas.textContent = state.replicas;
        metricStability.textContent = Number.isFinite(state.stability) ? `${state.stability}/100` : "--";
        metricAutopilot.textContent = state.autopilotLabel || "OFF";
      }

      function addMessage(role, text, isoTimestamp = "") {
        const div = document.createElement("div");
        div.className = `msg ${role}`;

        const textNode = document.createElement("p");
        textNode.className = "msg-text";
        textNode.textContent = text;

        const timeNode = document.createElement("span");
        timeNode.className = "msg-time";
        if (isoTimestamp) {
          const parsed = new Date(isoTimestamp);
          if (!Number.isNaN(parsed.getTime())) {
            timeNode.textContent = parsed.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          } else {
            timeNode.textContent = timestamp();
          }
        } else {
          timeNode.textContent = timestamp();
        }

        div.appendChild(textNode);
        div.appendChild(timeNode);
        messages.appendChild(div);
        messages.scrollTop = messages.scrollHeight;
      }

      function addTypingMessage() {
        const typing = document.createElement("div");
        typing.className = "msg bot typing";
        typing.id = "bot-typing";
        typing.innerHTML = '<span class="typing-dots">Bot is typing</span>';
        messages.appendChild(typing);
        messages.scrollTop = messages.scrollHeight;
      }

      function removeTypingMessage() {
        const typing = document.getElementById("bot-typing");
        if (typing) typing.remove();
      }

      function applyStateSnapshot(snapshot) {
        if (!snapshot || typeof snapshot !== "object") return;
        if (typeof snapshot.service === "string") state.service = snapshot.service;
        if (typeof snapshot.version === "string") state.version = snapshot.version;
        if (typeof snapshot.status === "string") state.status = snapshot.status;

        if (typeof snapshot.error_rate === "number") state.errorRate = snapshot.error_rate;
        if (typeof snapshot.latency_ms === "number") state.latency = snapshot.latency_ms;
        if (typeof snapshot.cpu_percent === "number") state.cpu = snapshot.cpu_percent;
        if (typeof snapshot.memory_percent === "number") state.memory = snapshot.memory_percent;
        if (typeof snapshot.ready_replicas === "number" && typeof snapshot.desired_replicas === "number") {
          state.replicas = `${snapshot.ready_replicas}/${snapshot.desired_replicas}`;
        }
        updateHealthPill();
      }

      function applyAnalyticsSnapshot(snapshot) {
        if (!snapshot || typeof snapshot !== "object") return;
        if (typeof snapshot.stability_score === "number") {
          state.stability = Number(snapshot.stability_score.toFixed(2));
          updateSnapshot();
        }
      }

      function applyAutopilotStatus(payload) {
        if (!payload || typeof payload !== "object") return;
        const meta = payload.autopilot && typeof payload.autopilot === "object" ? payload.autopilot : payload;
        if (!meta || typeof meta !== "object") return;

        const running = Boolean(meta.running);
        const cycles = typeof meta.cycles_completed === "number" ? meta.cycles_completed : null;
        if (running) {
          state.autopilotLabel = cycles !== null ? `ON (${cycles})` : "ON";
        } else {
          state.autopilotLabel = "OFF";
        }
        updateSnapshot();
      }

      function normalizeRole(role) {
        if (role === "assistant" || role === "bot" || role === "system") return "bot";
        return "user";
      }

      function apiCandidates(allowFallback = true) {
        const unique = new Set();
        const primary = normalizeBaseUrl(apiBase);
        if (primary) unique.add(primary);

        if (allowFallback) {
          unique.add("");
          unique.add("http://127.0.0.1:8000");
        }
        return Array.from(unique);
      }

      async function fetchJson(path, options = {}, allowFallback = true) {
        const candidates = apiCandidates(allowFallback);

        let lastError = null;

        for (const candidateBase of candidates) {
          const url = resolveApiUrl(path, candidateBase);
          try {
            const response = await fetch(url, options);
            let payload = {};
            try {
              payload = await response.json();
            } catch (err) {
              payload = {};
            }
            if (!response.ok) {
              const message = payload && payload.error ? payload.error : `Request failed (${response.status})`;
              throw new Error(message);
            }

            if (candidateBase && candidateBase !== apiBase) {
              apiBase = candidateBase;
              window.localStorage.setItem(API_BASE_STORAGE_KEY, apiBase);
            }
            return payload;
          } catch (err) {
            lastError = err;
          }
        }

        throw lastError || new Error("Request failed");
      }

      function renderHistory(history) {
        messages.innerHTML = "";
        if (!Array.isArray(history) || !history.length) {
          addMessage("bot", "Hello, I am your DevOps chatbot backend. Ask me for status, summary, diagnose, heal, or analytics.");
          return;
        }
        history.forEach((item) => {
          if (!item || typeof item !== "object") return;
          const role = normalizeRole(item.role);
          const text = typeof item.text === "string" ? item.text : "";
          const ts = typeof item.timestamp === "string" ? item.timestamp : "";
          addMessage(role, text, ts);
        });
      }

      async function loadInitialData() {
        try {
          const [stateResult, historyResult, analyticsResult, autopilotResult] = await Promise.allSettled([
            fetchJson(api.state),
            fetchJson(`${api.history}?limit=150`),
            fetchJson(`${api.analytics}?window=40`),
            fetchJson(api.autopilot),
          ]);

          if (stateResult.status !== "fulfilled") {
            throw stateResult.reason;
          }
          if (historyResult.status !== "fulfilled") {
            throw historyResult.reason;
          }

          const statePayload = stateResult.value;
          const historyPayload = historyResult.value;
          if (statePayload && statePayload.state) {
            applyStateSnapshot(statePayload.state);
          }
          if (analyticsResult.status === "fulfilled") {
            const analyticsPayload = analyticsResult.value;
            if (analyticsPayload && analyticsPayload.analytics) {
              applyAnalyticsSnapshot(analyticsPayload.analytics);
            }
          }
          if (autopilotResult.status === "fulfilled") {
            applyAutopilotStatus(autopilotResult.value);
          }
          renderHistory(historyPayload.messages || []);
        } catch (err) {
          messages.innerHTML = "";
          addMessage(
            "bot",
            `Backend not reachable: ${err.message}\n` +
              "Start backend: python3 server.py --host 127.0.0.1 --port 8000\n" +
              "Or open page with ?api=http://127.0.0.1:8000"
          );
        }
      }

      async function refreshAnalytics() {
        try {
          const payload = await fetchJson(`${api.analytics}?window=40`);
          if (payload && payload.analytics) {
            applyAnalyticsSnapshot(payload.analytics);
          }
        } catch (err) {
          // Ignore analytics refresh failures to keep chat responsive.
        }
      }

      async function refreshAutopilot() {
        try {
          const payload = await fetchJson(api.autopilot);
          applyAutopilotStatus(payload);
        } catch (err) {
          // Ignore autopilot refresh failures; older backends may not expose this route.
        }
      }

      async function respondToUser(text, delayMs) {
        addMessage("user", text);
        addTypingMessage();

        const startedAt = Date.now();
        try {
          const payload = await fetchJson(api.chat, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message: text,
              max_actions: 2,
            }),
          });

          const elapsed = Date.now() - startedAt;
          const extraDelay = Math.max(0, delayMs - elapsed);
          window.setTimeout(() => {
            removeTypingMessage();
            addMessage("bot", payload.reply || "No response received.", payload.timestamp || "");
            if (payload.state) applyStateSnapshot(payload.state);
            refreshAnalytics();
            refreshAutopilot();
          }, extraDelay);
        } catch (err) {
          removeTypingMessage();
          addMessage("bot", `Backend error: ${err.message}`);
        }
      }

      form.addEventListener("submit", (event) => {
        event.preventDefault();
        const text = input.value.trim();
        if (!text) return;
        input.value = "";
        respondToUser(text, 220);
      });

      chips.forEach((chip) => {
        chip.addEventListener("click", () => {
          if (chip.id === "clear-chat-btn") return;
          const text = chip.getAttribute("data-q") || "";
          respondToUser(text, 150);
        });
      });

      clearChatBtn.addEventListener("click", () => {
        addTypingMessage();
        fetchJson(api.clear, { method: "POST" })
          .then((payload) => {
            removeTypingMessage();
            messages.innerHTML = "";
            addMessage("bot", payload.reply || "Chat history cleared.", payload.timestamp || "");
            if (payload.state) applyStateSnapshot(payload.state);
            refreshAutopilot();
          })
          .catch((err) => {
            removeTypingMessage();
            addMessage("bot", `Clear failed: ${err.message}`);
          });
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "/" && document.activeElement !== input && !event.metaKey && !event.ctrlKey && !event.altKey) {
          event.preventDefault();
          input.focus();
        }
      });

      updateHealthPill();
      loadInitialData();
      window.setInterval(refreshAutopilot, 8000);
    </script>
  </body>
</html>
